@page "/"
@using basicblazorexample.API

<div id="sheet" class="body-space">
    @DisplaySheet()
</div>

@code{
    public Action<object> Capture<T>(Action<T> act)=>(a) => act((T) a);
    
    ///
    ///I have not found a proper way to go about implementing blazor components without major issues
    ///involving the access of shared variables and scoped functionality without doing this.
    ///It is acceptable considering this runs in the browser.
    ///My only issue is coming up with a solution to this that results in a coding pattern or paradigm that
    ///makes sense without project code fragmentation. 
    /// 
    public RenderFragment DisplaySheet()
    {

        
        void CapAct(DynObject obj)
        {
            int page = 0;
            int interval = 5;
            
            //TODO Set up the Table Elements display element to do this on its own. Later.
            void ModifyTable()
            {
                obj.TableChangeKey = Guid.NewGuid().ToString();
                obj.StateChanged();
            }

            //TODO Will have to have fetch data be stored in a location to be checked with a checksum
            //to see if the data held matches other recent polls, as modifying what's in the table
            //may have occured from another fetch that wasn't from this method.
            //Doing this would allow for the program to place the most up-to-date collection.
            //Probably an object like: Page, Items, TimeStamp, and Collection.
            //We pull the latest timestamped collection, in the order that they were requested.
            async void OnRemoveButtonClick(TableEntry entry)
            {

                int startPage = page;
                Console.WriteLine(entry.Id);

                entry.styleClass.Add("shrink");

                if (!await NameMethods.RemoveName(entry.Id))
                    Console.WriteLine("could not remove");
                
                if (obj.TableData.Count == 1 && page > 0)
                    startPage = page-1;
                
                await Task.Delay(1200);
                 
                var hold = await NameMethods.GetNameInstances(startPage, interval);
                if (startPage == page-1 || startPage == page)
                {
                    obj.TableData.Clear();
                    obj.TableData.AddRange(hold);
                    ModifyTable();
                }
            }

            obj.MakeWrapper = (content, id) => 
                @<TableEntry Id=@id OnRemoveButtonClick=@((Action<TableEntry>) OnRemoveButtonClick) Content=@content/>;

            EntryModal modalRef = null;
            
            void ModalCapture(EntryModal modal)
            {
                modalRef = modal;
                
                modal.TriggerHide += () =>
                {
                    modal.Show(false);
                    modal.StateChanged();
                };

                void NamePanelCapture(NameAddPanel panel)
                {
                    panel.OnSubmitButtonClick += () =>
                    {
                        NameMethods.GetNameInstances(page, interval).ContinueWith(e =>
                        {
                            obj.TableData.Clear();
                            obj.TableData.AddRange(e.Result);
                            obj.StateChanged();
                        });
                    };
                }

                modal.RenderContent = @<NameAddPanel Capture=@Capture((Action<NameAddPanel>)NamePanelCapture)/>;
            }
            
            obj.EntryModalInstance += () =>
            {
                return @<EntryModal Capture=@Capture((Action<EntryModal>) ModalCapture)/>;
            };

            void DoModalAction()
            {
                modalRef.Show(!modalRef.Displayed);
                obj.StateChanged();
            }
            
            obj.AddConfigurationButton(@<ConfiguredButton OnButton=@((Action) DoModalAction)
                                            HTML="Add Entry"/>);

            obj.LeftNavAction += async () =>
            {
                if (page <= 0) return;
                page--;
                
                var hold = await NameMethods.GetNameInstances(page, interval);
                obj.TableData.Clear();
                obj.TableData.AddRange(hold);
                ModifyTable();
            };
            
            obj.RightNavAction += async () =>
            {
                page++;
                
                var hold = await NameMethods.GetNameInstances(page, interval);
                if (hold.Length == 0)
                    page--;
                
                hold = await NameMethods.GetNameInstances(page, interval);
                obj.TableData.Clear();
                obj.TableData.AddRange(hold);
                ModifyTable();
            };
    //
            NameMethods.GetNameInstances(0, 5).ContinueWith(e =>
            {
                obj.TableData.Clear();
                
                foreach(var item in e.Result)
                    obj.TableData.Add(item);
                
                obj.StateChanged();
            });
        }

        return 
            @<DynObject Capture=@Capture((Action<DynObject>) CapAct)/>;
    }
}